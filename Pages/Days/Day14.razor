@page "/day-14"
@using System.Diagnostics
@using System.Text

@inject ISnackbar Snackbar

<MudPaper Width="100%" Class="mx-2 pa-2" Outlined="false" Square="true" Elevation="0">

	<MudText Typo="Typo.h4" GutterBottom="true">Day @Puzzle.Day: @Puzzle.Name</MudText>

	<MudText Typo="@Typo.body1" GutterBottom="true"><b>Puzzle Answer:</b> @Puzzle.SolutionA</MudText>

	<MudText Typo="Typo.body1" GutterBottom="true">--- Part Two ---</MudText>

	<MudText Typo="@Typo.body1" GutterBottom="true"><b>Puzzle Answer:</b> @Puzzle.SolutionB</MudText>

	<MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="@UpdatePuzzle">Update Puzzle</MudButton>
</MudPaper>

@code {
	private Puzzle Puzzle { get; set; } = new();
	private string PolymerTemplate { get; set; }
	private List<string> PairInsertions { get; set; } = new();

	protected override void OnAfterRender(bool firstRender)
	{
		if (firstRender)
		{
			Puzzle = Utilities.GetPuzzleInput("Day14");
			var data = Puzzle.Input.Split('\n', StringSplitOptions.RemoveEmptyEntries).ToList();
			PairInsertions = data.Skip(1).ToList();
			PolymerTemplate = data.First();

			SolvePartA();
			SolvePartB();
			StateHasChanged();
		}

	}


	private string FindPolyRule(string polyPair)
	{
		var matchingRule = PairInsertions.First(rule => rule.StartsWith(polyPair));
		return matchingRule.Skip(6).First().ToString();
	}

	private void SolvePartA()
	{
		for(int i = 0; i < 10; i++)
		{
			var matchingRules = new List<string>();
			var polymerBuilder = new StringBuilder();
			for(int j = 0; j < PolymerTemplate.Length - 1; j++)
			{
				var polyPair = String.Concat(PolymerTemplate.Skip(j).Take(2));
				matchingRules.Add(FindPolyRule(polyPair));
			}

			for(int k = 0; k < PolymerTemplate.Length; k++)
			{
				polymerBuilder.Append(PolymerTemplate.Skip(k).First());
				polymerBuilder.Append(matchingRules.Skip(k).Take(1).FirstOrDefault() ?? "");
			}

			PolymerTemplate = polymerBuilder.ToString();
		}

		var elements = PolymerTemplate.GroupBy(x => x).OrderByDescending(g => g.Count()).ToDictionary(grp => grp.Key, grp => (long)grp.Count());
		var mostCommon = elements.First().Value;
		var leastCommon = elements.Last().Value;
		Puzzle.SolutionA = (mostCommon - leastCommon).ToString();

	}

	private void SolvePartB()
	{

	}

	private async Task UpdatePuzzle()
	{
		await Utilities.UpdatePuzzleFile(Puzzle);
		Snackbar.Add("Puzzle JSON updated!", Severity.Success);
	}

}
